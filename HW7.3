public class Tree extends BTreePrinter{ // Fix this
  Node root;
  
  public Tree(Node root){
      this.root = root;
  }
  
  public Tree(){} // Dummy constructor (No need to edit)

  
  public void printTree(){
      // Pls use codes from the previous problem
      if(root != null)
        super.printTree(root);
      else
        System.out.println("Empty tree!!!");
  }

  public Node findKey(int search_key){
      // Pls use codes from the previous problem
      Node current = root;
      return findKey(current,search_key);
  }
  
  public static Node findKey(Node node, int search_key){
      // Pls use codes from the previous problem
      if(node == null) 
      {
          return null;
      }
      
      if(node.key == search_key) 
      {
          return node;
      }
      if(node.key > search_key)  
      {
          return findKey(node.left, search_key);
      } 
      else
      {
          return findKey(node.right, search_key);
      }
  }

  public static Node findMin(Node node){
      // Pls use codes from the previous problem
      if(node.left != null)
        {
            return findMin(node.left);
        }
      else
      {
          return node;
      }
  }
  
  
  // This function is for deleting the root node
  // If the node is not the root, please call the recursive version
  public void deleteKey(int key) {
      // There should be 6 cases here
      // Non-root nodes should be forwarded to the static function
    if (root == null) {
        System.out.println("Empty Tree!!!");
        return;
    }
  
      Node nodeToDelete = findKey(key);  // Find the node to delete
    if (nodeToDelete == null) {
        System.out.println("Key not found!!!");
        return;  // Key not found, nothing to delete
    }

    // Case 1: The tree is empty
    
    // If the node to delete is the root
    if (nodeToDelete == root) {
        // Case 2: The root has no children (leaf)
        if (root.left == null && root.right == null) {
            root = null;  // Tree becomes empty
        }
        // Case 3: The root has only a left child
        else if (root.left != null && root.right == null) {
            root = root.left;
            root.parent = null;
        }
        // Case 4: The root has only a right child
        else if (root.right != null && root.left == null) {
            root = root.right;
            root.parent = null;
        }
        // Case 5 and 6: The root has two children
        else {
            Node successor = findMin(root.right);  // Find in-order successor
            root.key = successor.key;  // Replace the root's key with the successor's key
            deleteKey(successor);  // Delete the successor recursively
        }
    } 
    // If nodeToDelete is not the root, call the recursive version
    else {
        deleteKey(nodeToDelete);
    }
  }
  
  // Use this function to delete non-root nodes
  public static void deleteKey(Node node){
      // There should be 7 cases here
      if (node.left == null && node.right == null) {
        if (node == node.parent.left) {
            node.parent.left = null;  // Remove node as left child
        } else {
            node.parent.right = null;  // Remove node as right child
        }
    }
    // Case 2: Node has only a left child
    else if (node.left != null && node.right == null) {
        if (node == node.parent.left) {
            node.parent.left = node.left;  // Replace node with its left child
        } else {
            node.parent.right = node.left;
        }
        node.left.parent = node.parent;
    }
    // Case 3: Node has only a right child
    else if (node.right != null && node.left == null) {
        if (node == node.parent.left) {
            node.parent.left = node.right;  // Replace node with its right child
        } else {
            node.parent.right = node.right;
        }
        node.right.parent = node.parent;
    }
    // Case 4 & 5: Node has two children
    else {
        Node successor = findMin(node.right);  // Find in-order successor
        node.key = successor.key;  // Replace node's key with the successor's key
        deleteKey(successor);  // Recursively delete the successor
    }
  }
  
}
